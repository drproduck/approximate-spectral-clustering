function [label, U] = LSCos(fea,k,opts)
% label = LSC(data,k,opts): Landmark-based Spectral Clustering with cosine
% affinity
% Input:
%       - data: the data matrix of size nSmp x nFea, where each row is a sample
%               point
%       - k: the number of clusters
%       opts: options for this algorithm
%           - p: the number of landmarks picked (default 1000)
%           - r: the number of nearest landmarks for representation (default 5)
%           - numRep: the number of replicates for the final kmeans (default 10)
%           - maxIter: the maximum number of iterations for final kmeans (default 100)
%           - mode: landmark selection method, currently support
%               - 'kmeans': use centers of clusters generated by kmeans (default)
%               - 'random': use randomly sampled points from the original
%                           data set
%           The following parameters are effective ONLY in mode 'kmeans'
%           - kmNumRep: the number of replicates for initial kmeans (default 1)
%           - kmMaxIter: the maximum number of iterations for initial kmeans (default 5)
% Output:
%       - label: the cluster assignment for each point
% Requre:
%       litekmeans.m
% Usage:
%       data = rand([100,50]);
%       label = LSC(data,10);
%Reference:
%
%	Xinlei Chen, Deng Cai, "Large Scale Spectral Clustering with
%	Landmark-Based Representation," AAAI 2011. 
%
%   version 2.0 --Dec./2011 
%   version 1.0 --Oct./2010 
%
%   Written by Xinlei Chen (endernewton AT gmail.com)
%              Deng Cai (dengcai AT gmail.com)



% Set and parse parameters
if (~exist('opts','var'))
   opts = [];
end


p = 1000;
if isfield(opts,'p')
    p = opts.p;
end

r = 5;
if isfield(opts,'r')
    r = opts.r;
end

maxIter = 100;
if isfield(opts,'maxIter')
    maxIter = opts.maxIter;
end

numRep = 10;
if isfield(opts,'numRep')
    numRep = opts.numRep;
end

nSmp=size(fea,1);
% fea = bsxfun(@rdivide, fea, sqrt(sum(fea.^2, 2)));

% Landmark selection
if isfield(opts, 'reps')
    reps = opts.reps;
else   
    kmMaxIter = 5;
    if isfield(opts,'kmMaxIter')
        kmMaxIter = opts.kmMaxIter;
    end
    kmNumRep = 1;
    if isfield(opts,'kmNumRep')
        kmNumRep = opts.kmNumRep;
    end
    [~, reps]=litekmeans(fea,p, 'Distance', 'cosine', 'MaxIter',kmMaxIter,'Replicates',kmNumRep);
    clear kmMaxIter kmNumRep
end


% Z construction
D = fea * reps';

%take the smallest distances from each row, store them in dump. 
%in the original D matrix, replace the taken elements with a large number
%so that next iteration ignores them
dump = zeros(nSmp,r);
idx = dump;
for i = 1:r
    [dump(:,i),idx(:,i)] = max(D,[],2);
    temp = (idx(:,i)-1)*nSmp+(1:nSmp)';
    D(temp) = 1e-100; 
end

% manipulate index to efficiently create sparse matrix Z
% Z is now (normalized to sum 1) smallest r landmarks in each row
sumD = sum(dump,2);
Gsdx = bsxfun(@rdivide,dump,sumD);
Gidx = repmat((1:nSmp)',1,r);
Gjdx = idx;
Z=sparse(Gidx(:),Gjdx(:),Gsdx(:),nSmp,p);

% Graph decomposition
feaSum = full(sqrt(sum(Z,1)));
feaSum = max(feaSum, 1e-12);
Z = Z./feaSum(ones(size(Z,1),1),:);
[U, S, V] = mySVD(Z,k+1);
U(:,1) = [];
V(:,1) = [];

U=bsxfun(@rdivide, U, sqrt(sum(U.^2, 2)));
V=bsxfun(@rdivide, V, sqrt(sum(V.^2, 2)));

% Final kmeans
if isfield(opts, 'kasp')
    reps_labels = litekmeans(V, k, 'Distance', 'cosine', 'MaxIter', maxIter, 'Replicates',numRep);

    label = zeros(size(idx, 1), 1);
    for i = 1:size(idx, 1)
        label(i) = reps_labels(idx(i));
    end
else
    label = litekmeans(U, k, 'Distance', 'cosine', 'MaxIter', maxIter, 'Replicates',numRep);
end
